
.. _program_listing_file_app_cli.h:

Program Listing for File cli.h
==============================

|exhale_lsh| :ref:`Return to documentation for file <file_app_cli.h>` (``app/cli.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #ifndef BERGAMOT_APP_CLI_H
   #define BERGAMOT_APP_CLI_H
   #include <algorithm>
   #include <cstdlib>
   #include <future>
   #include <iostream>
   #include <sstream>
   
   #include "common/definitions.h"
   #include "common/timer.h"
   #include "common/utils.h"
   #include "marian.h"
   #include "translator/byte_array_util.h"
   #include "translator/parser.h"
   #include "translator/response.h"
   #include "translator/response_options.h"
   #include "translator/service.h"
   
   namespace marian {
   namespace bergamot {
   
   // marian::bergamot:: makes life easier, won't need to prefix it everywhere and these classes plenty use constructs.
   
   namespace app {
   
   void wasm(const CLIConfig &config) {
     // Here, we take the command-line interface which is uniform across all apps. This is parsed into Ptr<Options> by
     // marian. However, mozilla does not allow a Ptr<Options> constructor and demands an std::string constructor since
     // std::string isn't marian internal unlike Ptr<Options>. Since this std::string path needs to be tested for mozilla
     // and since this class/CLI is intended at testing mozilla's path, we go from:
     //
     // cmdline -> Ptr<Options> -> std::string -> TranslationModel(std::string)
     //
     // Overkill, yes.
   
     const std::string &modelConfigPath = config.modelConfigPaths.front();
   
     Ptr<Options> options = parseOptionsFromFilePath(modelConfigPath);
     MemoryBundle memoryBundle = getMemoryBundleFromConfig(options);
   
     BlockingService::Config serviceConfig;
     BlockingService service(serviceConfig);
   
     std::shared_ptr<TranslationModel> translationModel =
         std::make_shared<TranslationModel>(options->asYamlString(), std::move(memoryBundle));
   
     ResponseOptions responseOptions;
     if (config.html) {
       responseOptions.HTML = true;
       responseOptions.alignment = true;  // Necessary for HTML
     }
     std::vector<std::string> texts;
   
     // Hide the translateMultiple operation
     for (std::string line; std::getline(std::cin, line);) {
       texts.emplace_back(line);
     }
   
     auto results = service.translateMultiple(translationModel, std::move(texts), responseOptions);
   
     for (auto &result : results) {
       std::cout << result.getTranslatedText() << std::endl;
     }
   }
   
   void decoder(const CLIConfig &config) {
     marian::timer::Timer decoderTimer;
     AsyncService::Config asyncConfig{config.numWorkers};
     AsyncService service(asyncConfig);
     auto options = parseOptionsFromFilePath(config.modelConfigPaths.front());
     MemoryBundle memoryBundle;
     Ptr<TranslationModel> translationModel = service.createCompatibleModel(options, std::move(memoryBundle));
     // Read a large input text blob from stdin
     std::ostringstream std_input;
     std_input << std::cin.rdbuf();
     std::string input = std_input.str();
   
     // Wait on future until Response is complete
     std::promise<Response> responsePromise;
     std::future<Response> responseFuture = responsePromise.get_future();
     auto callback = [&responsePromise](Response &&response) { responsePromise.set_value(std::move(response)); };
   
     service.translate(translationModel, std::move(input), std::move(callback));
     responseFuture.wait();
     const Response &response = responseFuture.get();
   
     for (size_t sentenceIdx = 0; sentenceIdx < response.size(); sentenceIdx++) {
       std::cout << response.target.sentence(sentenceIdx) << "\n";
     }
   
     std::cerr << "Total time: " << std::setprecision(5) << decoderTimer.elapsed() << "s wall" << std::endl;
   }
   
   void native(const CLIConfig &config) {
     AsyncService::Config asyncConfig{config.numWorkers};
     AsyncService service(asyncConfig);
   
     auto options = parseOptionsFromFilePath(config.modelConfigPaths.front());
     // Prepare memories for bytearrays (including model, shortlist and vocabs)
     MemoryBundle memoryBundle;
     if (config.byteArray) {
       // Load legit values into bytearrays.
       memoryBundle = getMemoryBundleFromConfig(options);
     }
   
     Ptr<TranslationModel> translationModel = service.createCompatibleModel(options, std::move(memoryBundle));
   
     // Read a large input text blob from stdin
     std::ostringstream std_input;
     std_input << std::cin.rdbuf();
     std::string input = std_input.str();
   
     ResponseOptions responseOptions;
     if (config.html) {
       responseOptions.HTML = true;
       responseOptions.alignment = true;  // Necessary for HTML
     }
   
     // Wait on future until Response is complete
     std::promise<Response> responsePromise;
     std::future<Response> responseFuture = responsePromise.get_future();
     auto callback = [&responsePromise](Response &&response) { responsePromise.set_value(std::move(response)); };
   
     service.translate(translationModel, std::move(input), std::move(callback), responseOptions);
     responseFuture.wait();
     Response response = responseFuture.get();
   
     std::cout << response.target.text;
   }
   
   }  // namespace app
   
   }  // namespace bergamot
   }  // namespace marian
   
   #endif  // BERGAMOT_APP_CLI_H
